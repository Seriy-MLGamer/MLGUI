///class GUI: Node
///
///A GUI container. It's useful for safe drawing and handling events of GUI elements with one call or storing GUI patterns.
///
///"MLGUI" library v0.0.1.
///(C) Серый MLGamer, 2021.
///MIT license.

MLG_GUI_REMOVE_ELEMENTS= 0b1
MLG_GUI_INHERIT_REMOVES=0b10

/**
 * \brief Alternative constructor. Adds GUI properties to entered container without creating new container. Useful for multiple inheritance in class constructors.
 * \param $this an output container.
 * \see MLG_GUI_new()
 */
fn MLG_GUI($this)
{
	MLG_Node($this)

	$this.texts=new(1, 1, INT)
	$this.images=new(1, 1, INT)
	$this.buttons=new(1, 1, INT)
	$this.windows=new(1, 1, INT)
	$this.window_focus=0
	$this.get_child_global_x=MLG_GUI_get_child_global_x
	$this.get_child_global_y=MLG_GUI_get_child_global_y
	$this.is_button_active=MLG_GUI_is_button_active
	$this.is_window_active=MLG_GUI_is_window_active
	$this.handle_window_events=MLG_GUI_handle_window_events

	$this.texts[0]=-1
	$this.images[0]=-1
	$this.buttons[0]=-1
	$this.windows[0]=-1
}
/**
 * \brief Creates a GUI container.
 * \return a GUI container.
 * \see MLG_GUI_draw()
 * \see MLG_GUI_handle_events()
 * \see MLG_GUI_remove()
 */
fn MLG_GUI_new()
{
	$gui=new()
	MLG_GUI($gui)
	ret($gui)
}
/**
 * \brief Removes a GUI container.
 * \param $this a GUI container.
 * \param $flags flags for remove.
 * \see MLG_GUI_new()
 */
fn MLG_GUI_remove($this, $flags)
{
	if $this>=0
	{
		if $flags&MLG_GUI_REMOVE_ELEMENTS
		{
			$a=0 while $a<get_size($this.windows)
			{
				MLG_Window_remove($this.windows[$a], !!($flags&MLG_GUI_INHERIT_REMOVES)*(MLG_WINDOW_REMOVE_ELEMENTS|MLG_WINDOW_INHERIT_REMOVES))
				$a+1
			}
			$a=0 while $a<get_size($this.texts)
			{
				MLG_Text_remove($this.texts[$a])
				$a+1
			}
			$a=0 while $a<get_size($this.images)
			{
				MLG_Image_remove($this.images[$a], !!($flags&MLG_GUI_INHERIT_REMOVES)*MLG_IMAGE_REMOVE_SOURCE)
				$a+1
			}
			$a=0 while $a<get_size($this.buttons)
			{
				MLG_Button_remove($this.buttons[$a])
				$a+1
			}
		}
		remove($this.windows)
		remove($this.texts)
		remove($this.images)
		remove($this.buttons)
		remove($this)
	}
}
/**
 * \brief Draws elements bound to the GUI container.
 * \param $this a GUI container.
 * \see MLG_GUI_new()
 */
fn MLG_GUI_draw($this)
{
	$a=0 while $a!=get_size($this.texts)
	{
		MLG_Text_draw($this.texts[$a])
		$a+1
	}
	$a=0 while $a!=get_size($this.images)
	{
		MLG_Image_draw($this.images[$a])
		$a+1
	}
	$a=0 while $a!=get_size($this.buttons)
	{
		MLG_Button_draw($this.buttons[$a])
		$a+1
	}
	$a=0 while $a!=get_size($this.windows)
	{
		MLG_Window_draw($this.windows[$a])
		$a+1
	}
}
/**
 * \brief Handles events of elments bound to the GUI container. Put this function in your event loop.
 * \param $this a GUI container.
 * \see MLG_Window_handle_events()
 * \see MLG_Button_handle_events()
 * \see MLG_GUI_new()
 */
fn MLG_GUI_handle_events($this)
{
	$a=get_size($this.windows) while $a!=0
	{
		$a-1
		MLG_Window_handle_events($this.windows[$a])
	}
	if $this.is_button_active($this)
	{
		$a=get_size($this.buttons) while $a!=0
		{
			$a-1
			MLG_Button_handle_events($this.buttons[$a])
		}
	}
}
fn MLG_GUI_get_child_global_x($this, $bindable)
{
	ret(MLG_get_global_x($bindable))
}
fn MLG_GUI_get_child_global_y($this, $bindable)
{
	ret(MLG_get_global_y($bindable))
}
fn MLG_GUI_is_button_active($this)
{
	ret(!$this.window_focus)
}
fn MLG_GUI_is_window_active($this, $window)
{
	ret($this.window_focus&&$this.windows[get_size($this.windows)-1]==$window)
}
fn MLG_GUI_handle_window_events($this, $window)
{
	if $this.window_focus
	{
		if $this.windows[get_size($this.windows)-1]!=$window
		{
			ret
		}
		$main_event=1
	}
	else
	{
		$main_event=0
	}
	$x=MLG_Bindable_get_global_x($window)
	$y=MLG_Bindable_get_global_y($window)-60*MLG_GUI_SCALE-1
	$width=$window.width*MLG_GUI_SCALE
	$height=($window.height+60)*MLG_GUI_SCALE+1
	$safe_area=MLG_WINDOW_SAFE_AREA*MLG_GUI_SCALE
	$escape=EVT[EVT_X]<$x-$safe_area||EVT[EVT_X]>=$x+$width+$safe_area||EVT[EVT_Y]<$y-$safe_area||EVT[EVT_Y]>=$y+$height+$safe_area
	if !$main_event
	{
		if EVT[EVT_TYPE]!=EVT_MOUSEBUTTONDOWN||$escape
		{
			ret
		}
		$this.window_focus=1
		$a=get_size($this.windows)-1 while $a!=-1&&$this.windows[$a]!=$window
		{
			$a-1
		}
		if $a==-1
		{
			logf("Error: Window #%i isn't found in GUI #%i while handling events.\n", $window, $this)
			exit(1)
		}
		copy($this.windows, $this.windows, $a, $a+1)
		$this.windows[get_size($this.windows)-1]=$window
	}
	MLG_handle_window_events($window, $x, $y, $width, $height, $safe_area, !$escape)
	if EVT[EVT_TYPE]==EVT_MOUSEBUTTONDOWN&&$escape
	{
		$this.window_focus=0
	}
}